# 자바 메모리 모델과 스레드

멀티태스킹은 요즘 컴퓨터 운영 체제에서 필수적인 기능이다.
컴퓨터의 연산 성능과 저장 통신 성능(디스크 I/O, 네트워크 통신, 데이터베이스 접근 등)의 격차가 크기 때문에 프로세서가 요청한 자원을 기다리며 그 시간에 무언가 다른 일을 처리하도록 동시에 여러 작업을 처리하도록 한다.

또한 서버는 서비스를 여러 클라이언트에 동시에 제공해야 한다. 프로그램이 스레드를 동시에 많이 운용할수록 효율이 높아지지만 같은 데이터를 두고 스레드끼리 자주 경합하여 다른 스레드가 멈추거나 교착 상태에 빠지면 동시성에 크게 감소하게 된다.

</br>

### 하드웨어에서의 효율과 일관성

물리 머신에서 발생하는 동시성 문제는 가상 머신에서의 동시성 문제와 비슷한 점이 많다.

프로세서는 데이터를 읽고 작업 결과를 저장해야 하므로 메모리는 반드시 필요하다. 메모리는 프로세서에 비해 속도가 느리기 때문에 현대 컴퓨터에서는 둘 사이에 캐시 계층을 하나 이상 둔다. 필요한 데이터를 캐시에 복사해 작업을 빠르게 수행하고, 작업이 완료되면 결과 데이터를 캐시에서 메모리로 동기화한다. 이렇게 캐시 계층을 두면 프로세서는 메모리의 느린 I/O를 기다릴 필요가 없다.

하지만 캐시를 사용하게 되면 컴퓨터 시스템이 복잡해지면서 캐시 일관성(Cache coherence)라는 문제가 발생한다.

<img width="507" alt="image" src="https://github.com/user-attachments/assets/e8108552-aade-4370-92d4-45a5022f47e8">

멀티프로세서 시스템에서 프로세서는 각각의 캐시를 갖춘 채 메인 메모리를 공유한다. 여러 프로세서가 메인 메모리의 같은 영역을 작업하더라도 프로세서별 캐시 데이터는 서로 다를 수 있다. 이 경우 데이터를 메인 메모리로 동기화할 때는 정해진 프로토콜을 따라야 한다.
대표적인 프로토콜로는 MSI, MESI(일리노이 프로토콜), MOSI, 시냅스, 파이어플라이, 드래곤 프로토콜 등이 있다.

비순차 실행 최적화(out-of-order execution optimization)
- 프로세서가 명령어를 실행하는 순서가 입력 코드에 기술된 명령어 순서와 다를 수 있다는 뜻
- 프로세서는 비순차 실행 결과와 순차적으로 실행했을 때의 결과가 같도록 재구성
  => JVM에서는 JIT 컴파일러가 **명령어 재정렬**이라는 최적화를 수행

</br>

### 자바 메모리 모델

- 다양한 하드웨어, 운영 체제의 서로 다른 메모리 모델로부터 자바 프로그램을 보호하고자 정의됨
- 자바 프로그램은 플랫폼에 상관없이 메모리를 일관된 방식으로 이용할 수 있게됨

#### 메인 메모리와 작업 메모리

자바 메모리 모델의 주된 목적은 프로그램에서 다양한 변수에 접근하는 규칙을 정하는 것이다. 가상 머신의 메모리에서 변수에 값을 저장하고 가져오는 저수준 정보에 중점을 둔다.

메인 메모리
- 자바 프로그램의 모든 변수는 메인 메모리에 저장
  > 이때 메인 메모리는 물리적인 메인 메모리가 아닌 가상 머신이 관리하는 메모리

작업 메모리
- 프로세서의 캐시와 비슷한 역할
- 해당 스레드가 사용하는 변수가 저장된 메인 메모리의 복사본이 담겨있음
- 스레드가 변수를 읽고 쓰는 모든 연산이 수행됨
- 스레드끼리 서로의 작업 메모리에 직접 접근할 수 없고, 메인 메모리를 거쳐 값을 전송해야함

#### 메모리 간 상호 작용

자바 메모리 모델에 정의된 메모리 간 상호 작용에 대한 8가지 기본 연산
> - 잠금(lock) : 메인 메모리에 존재하는 변수를 특정 스레드만 사용할 수 있는 상태로 만든다
> - 잠금 해제(unlock) : 잠겨 있는 변수를 잠금 해제한다. 잠금이 해제된 변수는 다른 스레드에 의해 잠길 수 있다.
> - 읽기(read) : 뒤이어 수행되는 적재 연산을 위해 메인 메모리의 변숫값을 특정 스레드의 작업 메모리로 전송한다.
> - 적재(load) : 읽기 연산으로 메인 메모리에서 얻어온 값을 작업 메모리의 변수에 복사해 넣는다.
> - 사용(use) : 작업 메모리의 변숫값을 실행 엔진으로 전달한다. 가상 머신이 변숫값을 사용하는 바이트코드 명령어를 만날 때마다 실행된다.
> - 할당(assign) : 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당한다. 가상 머신이 변수에 값을 할당하는 바이트코드 명령어를 만날 때마다 실행된다.
> - 저장(store) : 뒤이어 수행되는 쓰기 연산을 위해 작업 메모리의 변숫값을 메인 메모리로 전송한다.
> - 쓰기(write) : 저장 연산으로 작업 메모리에서 얻어온 값을 메인 메모리의 변수에 기록한다.

- 메인 메모리에서 작업 메모리로 변수를 복사하려면 **읽기와 적재**를 순서대로 수행해야함
- 반대로 작업 메모리의 변수를 메인 메모리로 동기화하려면 **저장과 쓰기**를 순서대로 수행해야함
- '순서대로' 수행되어야 할 뿐 '바로 이어서' 수행될 필요는 없음
  => 읽기와 적재 사이에 다른 연산이 수행될 수 있음

8가지 기본 연산을 수행할 때 지켜야 하는 규칙들
... something



#### volatile 변수용 특별 규칙

volatile 키워드는 JVM이 제공하는 가장 가벼운 동기화 메커니즘
변수가 volatile로 정의될 때 갖게되는 두 가지 특성
- 모든 스레드에서 이 변수를 투명하게 볼 수 있다.
   - '가시성을 보장한다'라고 말함
   - 한 스레드가 값을 수정하면 다른 스레드도 새로운 값을 즉시 알게됨
   - 일반 변수의 경우 값이 메인 메모리를 거쳐 전달되기 때문에 이런 특성을 보장받지 못함

volatile 변수의 특성
- volatile 변수에 대한 오해
  - volatile 변수의 값은 모든 스레드에서 일관되므로 volatile 변수를 사용한 작업은 동시성 환경에서 안전하다.
    => volatile 변수 사용 시 동시성 환경에서 안전하다는 것은 과장된 것
       - 자바의 산술 연산자는 원자적이 아니라 volatile 변수라도 멀티스레드 환경에서 완벽하게 안전하지 못함
- 명령어 재정렬 최적화를 막아줌
  - 일반 변수는 메서드 실행 중 할당 결과를 이용해야 하는 모든 위치에서 올바른 결과를 얻는다는 점만 보장됨
  - 변수 할당 작업의 실행 순서가 프로그램 코드 순서와 같다는 걸 보장하지 않음
  - 아직은 잘 모르겠지만 volatile 키워드를 사용한 코드의 어셈블리 코드를 보면 메모리에 동기화할 때는 이전의 모든 작업이 수행되었음을 뜻하므로 '명령어 재정렬은 메모리 장벽을 넘을 수 없다'는 효과가 생겨난다고 한다.
- 다른 동기화 도구보다 더 빠른 실행
  - volatile은 특정 상황에서 락 방식보다 성능이 좋음
    > - volatile 변수의 읽기 성능은 일반 변수와 거의 같음
    > - 쓰기는 더 느릴 수 있음
    >   => 프로세서가 명령어를 재정렬하지 못하도록 하기 위해 네이티브 코드에 메모리 장벽 명령어를 끼워 넣기 때문

#### long과 double 변수용 특별 규칙

자바 메모리 모델에서는 잠금, 잠금 해제, 읽기, 적재, 할당, 사용, 저장, 쓰기 연산이 모두 원자적이어야 하지만 64비트 데이터 타입인 long과 double에는 좀 더 느슨한 규칙이 적용된다.
- 가상 머신은 volatile로 지정되지 않은 64비트 데이터의 읽기와 쓰기는 32비트 연산 2개로 나눠 처리할 수 있다.
  - 64비트 데이터의 적재, 저장, 읽기, 쓰기 연산의 원자성을 보장할지 여부를 가상 머신이 선택할 수 있다.
    => 이를 'long과 double 변수의 비원자적 처리'라고 함
- volatile로 선언되지 않은 long, double 변수를 여러 스레드가 공유하고 동시에 읽고 수정하면 '반만 수정된' 값을 읽을 수 있다.
  => 하지만 이런 상황은 현실에서 거의 일어나지 않음


#### 원자성, 가시성, 실행 순서

원자성
- 자바 메모리 모델이 직접 보장하는 원자적 변수 연산은 읽기, 적재, 할당, 사용, 저장, 쓰기
- 애플리케이션 수준에서 원자성을 더 넓은 범위로 보장해야할 때를 위해 자바 메모리 모델은 잠금과 잠금 해제 연산을 제공
  - 가상 머신이 잠금과 잠금 해제 연산을 직접 제공하지 않고, 한 단계 추상화된 바이트코드 명령어인 monitorenter와 monitoerexit을 이용하도록 함
    - 자바 코드에서 synchronized 키워드로 동기화된 블록에 해당


가시성
- 가시성이란 공유 변수의 값을 한 스레드가 수정하면 수정 결과를 다른 스레드가 즉시 알 수 있다는 것
- 자바 메모리 모델은 변숫값이 수정되면 새로운 값을 메인 메모리에 즉시 동기화하고, 작업 메모리의 변숫값을 읽을 때 메인 메모리로부터 값을 갱신하는 식으로 가시성을 확보
- 자바에서 가시성 확보용 키워드로 synchronized와 final도 있음
  - synchronized : 변수의 잠금을 해제하기 전에 변수의 값을 메인 메모리로 다시 동기화해야 한다라는 규칙이 확보됨
  - final : 생성자에서 초기화되며, 생성이 완벽하게 끝나지 않은 객체의 참조를 다른 스레드에 전달할 수 없게됨


실행 순서
- 자바에서 스레드 사이에서 작업 순서를 보장하기 위해 volatile과 synchronized 키워드를 제공
  - volatile은 '명령어 재정렬을 금지한다'라는 의미를 포함
  - synchronized는 '락을 소유한 단 하나의 스레드만이 변수에 접근 할 수 있다'라는 규칙에 의거해 작업 순서를 정함

#### 선 발생 원칙

'선 발생'이란 자바 메모리 모델에서 정의된 두 작업의 수행 순서 관계를 말함
- e. g. 작업 A는 작업 B보다 선 발생한다
  => 작업 B가 수행되기 전 작업 A의 영향을 작업 B에서 관찰할 수 있다.

선 발생 원칙은 데이터 경합 발생 여부와 스레드 안전성을 확인하는데 매우 유용한 수단
- 이 원칙을 따라 몇 가지 간단한 규칙만으로 동시성 환경에서 두 작업의 충돌 가능성 판단 문제를 해결할 수 있음


### 자바와 스레드

- 동시성이 반드시 멀티스레딩을 뜻하지 않음
- PHP의 경우 멀티프로세스 동시성이 매우 일반적
- 자바에서 동시성은 기본적으로 스레드와 분리해 이야기할 수 없음

#### 스레드 구현

스레드
- 프로세스보다 가벼운 스케줄링 단위
- 스레드 각각은 프로세스 자원을 공유할 수 있으며 독립적으로 스케줄링됨
- 스케줄링 최소 단위
  - JDK 20까지 자바에서는 스레드가 프로세서 자원 스케줄링의 최소 단위
  - JDK 21에 와서는 가상 스레드가 도입되어 변화됨(어떻게?)

스레드 구현
- java.lang.Thread 클래스의 인스턴스가 하나의 스레드
- Thread 클래스는 대부분의 자바 클래스 라이브러리 API와 다르게 핵심 메서드 모두가 네이티브 코드로 구현되어 있음

스레드 구현 방법
1. 커널 스레드 구현
  - 1:1 구현이라고도 함
  - 운영 체제 커널에서 직접 지원하는 스레드이며 스레드의 작업을 각 프로세서에 매핑하는 역할
  - 커널 스레드는 직접 사용하지 않고, 고수준 인터페이스인 경량 프로세스를 이용
    - 일반적으로 스레드라고 부르는 것을 경량 프로세스
    - 경량 프로세스는 커널 스레드의 도움을 받기 때문에 커널 스레드가 먼저 지원되어야 경량 프로세스도 존재할 수 있음  
      => 경량 프로세스와 커널 스레드 사이 1:1 관계를 일대일 스레딩 모델이라고 함
    - 경량 프로세스는 커널 스레드의 도움으로 독립된 단위로 스케줄링됨
    - 경량 프로세스 하나가 블록되더라도 전체 프로세스는 영향을 받지 않음
    - 경량 프로세스의 한계
      1. 커널 스레드를 기반으로 구현되기 때문에 생성, 소멸, 동기화 등 다양한 스레드 연산이 시스템 호출로 이루어짐  
        시스템 호출은 사용자 모드와 커널 모드 전환을 수반하기 때문에 실행 비용이 상대적으로 높음
      2. 경량 프로세스 하나가 커널 스레드 하나에 매핑되기 때문에 경량 프로세스는 일정량의 커널 자원을 소모함(예: 커널 스레드의 스택 공간)  
        => 시스템이 지원할 수 있는 경량 프로세스 개수에는 제한이 있음
2. 사용자 스레드 구현
  - 1:N 구현이라고도 함
  - 넓은 의미 => 커널 스레드가 아닌 스레드는 일종의 사용자 스레드로 볼 수 있음
  - 좁은 의미 => 온전히 사용자 공간에서 구현되는 스레드 라이브러리를 가리킴
    - 사용자 스레드의 생성, 소멸, 동기화, 스케줄링을 모두 커널의 도움없이 온전히 사용자 공간에서 처리  
      - 매우 빠르고 저렴하여 더 많은 스레드를 지원할 수 있음
      - 일부 고성능 데이터베이스는 멀티스레딩을 사용자 스레드로 구현
  - 장점 : 시스템 커널의 지원이 필요 없음
  - 단점 : 시스템 커널의 지원을 받지 못함
    - 스레드의 생성, 소멸, 동기화, 스케줄링 등 모든 작업을 사용자 프로그램 자체에서 처리해야함
    - 그 중 블로킹 처리와 멀티프로세서 시스템에서 스레드를 특정 프로세서에 매핑 같은 문제를 해결하기가 어렵고 일부는 불가능하기까지 함
  - 사용자 스레드로 구현된 프로그램은 일반적으로 복잡해서, 일반적인 애프릴케이션에서는 사용자 스레드를 잘 사용하지 않음
3. 하이브리드 구현
  - 커널 스레드와 사용자 스레드를 함께 이용하는 하이브리드 구현 방법, N:M 구현이라고함
  - 사용자 스레드와 경량 프로세스가 공존
    - 사용자 스레드는 사용자 영역에 구현  
      => 생성, 소멸, 스케줄링 비용이 저렴하고 감당할 수 있는 동시성 규모가 커짐
    - 경량 프로세스는 사용자 스레드와 커널 스레드 사이에서 가교 역할을 함  
      => 커널이 지원하는 스레드 스케줄링과 프로세서 매핑 기능을 활용할 수 있음
  - 사용자 스레드와 경량 프로세스의 비율이 불확실한 N:M 관계이며, 다대다 스레딩 모델이라 함


자바 스레드 구현
- 자바 가상 머신 명세에서 자바 스레드의 구현 방식은 규정하지 않고 가상 머신에 따라 다를 수 있음
- JDK 1.2 이전 클래식 VM => 자바 스레드를 그린 스레드라는 이름의 사용자 스레드로 구현
- JDK 1.3 부터는 주류 플랫폼의 주류 가상 머신들이 운영 체제의 기본 스레드 모델(주로 일대일 스레딩 모델)로 선회
  - 예시 :
    - 핫스팟의 경우 자바 스레드 중간에 간접 참조 없이 운영 체제의 기본 스레드에 직접 매핑됨
    - 핫스팟은 스레드 스케줄링에 관여하지 않고, 운영 체제가 온전히 처리

#### 자바 스레드 스케줄링

스레드 스케줄링은 시스템이 프로세서 사용 권한을 스레드에 할당하는 일  
- 주요 스케줄링 방법
  - 협력적 스케줄링
    > - 스레드 실행 시간을 스레드 스스로가 제어함  
    >   => 일을 마친 스레드는 다른 스레드로 전환되도록 시스템에 적극적으로 알려야 함
    > - 협력적 스케줄링 모델의 이점 :  
    >   - 구현하기 쉬움
    >   - 일반적으로 동기화 문제가 일어나지 않음  
    >     => 스레드가 다른 스레드로 전환되기 전 자신이 완수해야 하는 일을 알고 있기 때문 (e. g. 루아의 코루틴)
    > - 협력적 스케줄링 모델의 단점 :  
    >   - 스레드 실행 시간을 제어할 수 없음  
          => 스레드 코드에 문제가 있어서 다른 스레드로 전환하게끔 시스템에 요청하지 않으면 프로그램이 멈추게됨
  - 선점형 스케줄링
    > - 각 스레드의 실행 시간을 시스템이 할당하며 스레드는 전환 시점을 스스로 결정하지 못함
    > - 자바는 선점형 스케줄링을 이용  
    >   => 작업 관리자를 이용해 시스템 충돌 없이 해당 프로세스만 종료할 수 있음
- 자바 스레드의 스케줄링은 시스템이 자동으로 수행하지만, 특정 스레드에 더 많거나 적은 실행 시간을 할당하도록 운영 체제에 '권고' 할 수 있다.
  - 스레드에 우선순위를 설정(총 10단계), 시스템은 실행 준비를 마친 스레드 중 우선순위가 높은 스레드를 선택해 실행할 가능성이 높음  
    => 하지만 결국 결정하는 주체는 운영 체제

#### 상태 전이

자바 언어에서 스레드의 상태는 총 6가지이다. 어느 시점이든 스레드는 이 중 한 상태가 되며, 특정 메서드를 호출하여 다른 상태로 전이할 수 있다.  

6가지 상태는 다음과 같다.  
- 신규 : 스레드 생성 후 아직 시작되기 전 상태
- 실행 중 : 
  - 운영 체제 스레드의 상태 중에서 실행 중(running)과 준비(ready)에 해당  
  - 스레드가 실행 중이거나 운영 체제가 실행 시간을 할당하기를 기다리는 중  
- 무기한 대기 : 
  - 프로세서 실행 시간이 할당되지 않았고, 다른 스레드가 명시적으로 깨워주기를 기다리는 중  
  - 다음 메서드들이 스레드를 무기한 대기 상태로 만듦  
    - 타임아웃 매개 변수를 설정하지 않은 Object::wait()
    - 타임아웃 매개 변수를 설정하지 않은 Thread::join()
    - LockSupport::park()
- 시간 제한 대기 :  
  - 프로세서 실행 시간이 할당되지 않았으나 일정 시간이 지나면 시스템에 의해 자동으로 깨어남
  - 다음 메서드들이 스레드를 시간 제한 대기 상태로 만듦
    - Thread::sleep()
    - 타임아웃 매개 변수를 설정한 Object::wait()
    - 타임아웃 매개 변수를 설정한 Thread::join()
    - LockSupport::parkNanos()
    - LockSupport::parkUntil()
- 블록 : 배타적 락을 얻을 때까지 대기
- 종료 : 스레드가 실행을 마침

</br>

<img width="595" alt="image" src="https://github.com/user-attachments/assets/c9321083-9ebe-4b7d-96cc-334c59f9d8e9">

</br>

### 자바와 가상 스레드

자바는 다양한 운영 체제별 스레드 모델의 차이를 숨기는 통합된 스레드 인터페이스를 제공한다.  
그래서 수많은 멀티스레드 애플리케이션과 프레임워크가 등장하는데 편의성이 제공되었다. 

#### 커널 스레드의 한계

- 과거는 ~~ 현재는 브라우저-서버 시스템에서는 MSA의 여러 서비스의 응답을 취합한 최종 응답을 합리적인 시간 안에 완성할 수 있ㅇ어야함
- 자바의 기존 동시성 프로그램 메커니즘은 MSA와 어울리지 않음  
  => JVM은 주로 1:1 커널 스레드 모델을 채택해왔기 때문
- 기존 자바 웹서버의 스레드 풀 용량은 수십에서 200 개정도. 이런 스레드 풀에 수백만 개의 요청을 쏟아부으면, 시스템이 처리할 수는 있더라도 스레드 전환 비용이 상당하게 됨

#### 코루틴의 귀환

- 커널 스레드가 전환 비용이 높은 이유
  - 비용은 주로 사용자 모드와 커널 모드 사이의 전환 비용
  - 주로 인터럽트에 응답하고 실행 사이트의 데이터를 저장했다가 복원하는 비용  
    > - 스레드 A -> 시스템 인터럽트 -> 스레드 B
    > - 스레드 A에서 B로 전환할때 A의 문맥 데이터를 보관한 뒤  
        레지스터와 메모리 페이징 등을 B가 이전에 일시 정지된 시점과 똑같게 복원해야함
- 멀티스레딩을 운영 체제 차원에서 지원하기 시작하면서 애플리케이셔
  - 

#### 가상 스레드: 자바의 해법

