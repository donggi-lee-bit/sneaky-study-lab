# 13. 스레드 안전성과 락 최적화

**절차 지향 프로그래밍**
- 소프트웨어 산업 초기 알고리즘이 프로그래밍의 중심
- 데이터와 절차를 구분
  - 데이터: 문제 공간의 개체를 표현
  - 프로그램: 데이터를 처리하는데 사용  
=> 이러한 사고방식을 컴퓨터 관점으로 추상화해 문제를 해결하는게 *절차 지향 프로그래밍*

**객체 지향 프로그래밍**
- 개발 효율을 높이고 규모가 훨씬 큰 소프트웨어를 구축할 수 있는 길을 열게됨
- 하지만 현실 세계와 컴퓨터 세계가 완전히 같을 수 없다는 문제가 있음
  ```markdown
  - 현실 세계의 객체가 작업 도중 인터럽트되어 다른 객체로 전환됨
  - 작업이 잠시 중단된 상태에서 객체 속성(데이터)이 바뀌어 이전 값이 의미가 없어짐
  => 이러한 문제는 현실 세계에서는 일어나지 않지만 컴퓨터 세계에서는 흔한 일
  ```

이러한 이유로 좋은 설계 원칙이라도 때로는 현실과 타협해야할 때가 있다.  
프로그램이 컴퓨터에서 '올바르게' 실행되는게 먼저고, 더 빨리 실행되도록 최적화하는 일은 그 후에 고민해야 한다.

## 13.2 스레드 안전성

일반적으로 이야기하는 스레드 안전성의 정의  
`어떤 객체를 여러 스레드에서 동시에 안전하게 사용할 수 있다면 그 객체는 스레드 안전하다`

Java Concurrency In Practice의 저자 브라이언 게츠가 내린 스레드 안정성의 정의
```
여러 스레드가 한 객체에 동시에 접근할 때, 어떤 런타임 환경에서든 다음 두 조건을 모두 충족하면서  
객체를 호출하는 행위가 올바른 결과를 얻을 수 있다면 '그 객체는 스레드 안전하다'라고 말한다.
- 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요가 없다.
- 추가적인 동기화 수단이나 호출자 측에서 조율이 필요 없다.
```

### 13.2.1 자바 언어의 스레드 안전성

스레드 안전성은 여러 스레드가 **공유하는 데이터**에 대한 것이다. 스레드가 하나이거나 코드에서 다른 스레드와 아무런 데이터를 공유하지 않는다면, 프로그램이 순차적으로 실행되든 여러 스레드가 동시에 실행되든 스레드 안전성 관점에서는 차이가 없다.  

스레드 안전성은 '안전함의 정도'에 따라 여러 단계로 분류된다. 자바에서는 다음과 같이 나눌 수 있다.
```
- 불변
- 절대적 스레드 안전
- 조건부 스레드 안전
- 스레드 호환
- 스레드 적대적
```

**불변**
- 문자 그대로 '변하지 않는다'는 뜻
- 자바 메모리 모델이 개정된 JDK 5 이후 자바 언어에서 불변 객체는 객체 자체의 메서드 구현과 호출자 모두 아무런 안정장치 없이도 스레드 안전하다.(final 키워드)
- 공유 데이터가 객체라면 객체의 메서드가 자신의 상태를 수정하지 않도록 해야 한다.  
  ```java
  java.lang.String 객체의 경우
  - String은 불변 객체
  - 사용자가 호출하는 substring(), replace(), concat() 등의 메서드는 원래의 값을 그대로 둔 채 새로 생성한 String 객체를 반환하는 식으로 구현됨
  ```
  - 객체의 메서드가 자신의 상태에 영향을 주지 않는 방법으로 상태에 해당하는 모든 변수를 final로 선언하는 방법이 있다.

**절대적 스레드 안전**
- 어떤 런타임 환경에서든 호출자가 추가적인 동기화 조치를 할 필요 없다
  - 브라이언 게츠가 제시한 스레드 안전성 정의를 충족  
  => 조건을 만족시키려면 많은 비용이 발생하고 비현실적일 수도 있음
- 자바 API에서 스레드 안전하다고 표시된 클래스 대부분이 절대적 스레드 안전을 의미하지는 않음
  ```java
  - java.util.Vector는 add(), get(), size() 등의 모든 메서드가 synchronized 메서드로 스레드 안전
  - 하지만 멀티스레드 환경에서 호출자가 추가적인 동기화 조치 없이 사용하면 안전하지 않을 수 있음
  ```

**조건부 스레드 안전**
- 일반적으로 '스레드 안전하다'라고 말하는 안전 수준
- 단일 작업을 별도의 보호 조치 없이 스레드로부터 안전하게 수행한다. 하지만 특정 순서로 연달아 호출하는 상황에서도 정확성을 보장하려면 호출자에게 추가로 동기화해야 할 수 있다.
- 자바의 Vector, HashTable, 그리고 Collections 클래스의 synchronized Collection() 메서드로 래핑한 컬렉션

**스레드 호환**
- 객체 자체는 스레드로부터 안전하지 않지만 호출자가 적절히 조치하면 멀티스레드 환경에서도 안전하게 사용할 수 있음
- 이러한 클래스는 일반적으로 '스레드 안전하지 않다'고 말함
- 자바의 클래스 대다수가 이 분류에 속함

**스레드 적대적**
- 호출자가 동기화 조치를 취해도 멀티스레드 환경에서 안전하게 사용할 수 없다는 뜻
- 자바에서는 처음부터 스레드를 지원해 스레드 적대적 코드는 드뭄

### 13.2.2 스레드 안전성 구현

**상호 배제 동기화**
- 가장 일반적이면서 가장 중요한 동시성 보장 수단
- 대표적인 동기화 수단으로 뮤텍스가 있으며, 임계 영역과 세마포어도 상호 배제 구현에 흔히 쓰임
- 자바에서 상호 배제 동기화
  ```
  코드 블록을 동기화하는 synchronized
  - javac로 컴파일하면 monitorenter, monitorexit라는 두 가지 바이트코드 명령어가 생성되며, 각각 동기화 블록 전후에 실행됨
  - 락을 소유한다는 건 실행 비용 측면에서 상당히 무거운 작업
    - 플랫폼 스레드를 정지하거나 깨우려면 운영 체제의 도움을 얻어야함  
      => 사용자 모드와 커널 모드 사이의 모드 전환에서 프로세서 시간을 많이 소모
  
  그 외 java.util.concurrent, java.util.concurrent.locks.Lock
  - 자바 언어에서 Lock 인터페이스를 이용하여 논블록 구조의 상호 배제 동기화를 구현할 수 있게됨  
    => 클래스 라이브러리 수준에서 동기화를 구현하여 다른 스케줄링 알고리즘, 특성, 성능, 의미를 갖는 다양한 락으로 확장할 수 있게 됨
    - ReentrantLock이 대표적인 예
      - synchronized와 똑같이 재진입이 가능한 락
      - 대기 중 인터럽트, 페어 락, 둘 이상의 조건 지정 등 더 향상된 기능을 제공
        - 대기 중 인터럽트: 락을 얻기 위해 대기 중인 스레드가 락을 포기하고 다른 일을 할 수 있음
        - 페어 락: 같은 락을 얻기 위해 대기하는 스레드가 많을 때 락 획득을 시도한 시간 순서대로 락을 얻게 됨
        - 둘 이상의 조건 지정: newCondition() 메서드를 여러 번 호출해 동시에 여러 개의 Condition 객체와 연결 지을 수 있음
  - JDK 5까지는 synchronized가 성능을 크게 떨어뜨려 Lock이 상대적으로 안정적
    - 하지만 JDK 6 이후 버전에서 synchronized 최적화가 이루어져 ReentrantLock과 선택할 때 성능은 고려 대상이 아니게 됨
  - synchronized가 권장되는 상황
    - 자바 구문 수준의 동기화 수단으로 명확하고 간결함
      - Lock 인터페이스는 낯설고 기본 동기화 기능만 필요하다면 synchronized가 나음
    - Lock은 finally 블록으로 락을 해제해야하는 반면 synchronized는 예외 발생 시 락 해제를 JVM이 보장해줌
    - JDK 5에서는 ReentrantLock의 성능이 우수했으나 현재 동기화 최적화는 JVM에 맡기는게 유리
      - synchronized 사용 시 JVM이 스레드 및 락과 관련된 내부 정보를 활용할 수 있음
      - Lock을 사용하면 JVM은 어느 스레드가 어느 락을 소유하고 있는지 알기 어려움
  ```

**논블로킹 동기화**
- 상호 배제 동기화의 큰 문제는 스레드 일시 정지와 깨우기로 인한 성능 저하다.  
  - 이런 동기화를 블로킹 동기화라고 함
  - 락과 같은 동기화 장치가 없으면 반드시 문제가 생길 것이라 가정하여, 경합이 실제로 벌어지는지와 상관없이 락을 검
- 

## 13.3 락 최적화
