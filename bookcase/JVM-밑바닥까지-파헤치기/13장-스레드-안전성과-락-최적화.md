# 13. 스레드 안전성과 락 최적화

**절차 지향 프로그래밍**
- 소프트웨어 산업 초기 알고리즘이 프로그래밍의 중심
- 데이터와 절차를 구분
  - 데이터: 문제 공간의 개체를 표현
  - 프로그램: 데이터를 처리하는데 사용  
=> 이러한 사고방식을 컴퓨터 관점으로 추상화해 문제를 해결하는게 *절차 지향 프로그래밍*

**객체 지향 프로그래밍**
- 개발 효율을 높이고 규모가 훨씬 큰 소프트웨어를 구축할 수 있는 길을 열게됨
- 하지만 현실 세계와 컴퓨터 세계가 완전히 같을 수 없다는 문제가 있음
  ```markdown
  - 현실 세계의 객체가 작업 도중 인터럽트되어 다른 객체로 전환됨
  - 작업이 잠시 중단된 상태에서 객체 속성(데이터)이 바뀌어 이전 값이 의미가 없어짐
  => 이러한 문제는 현실 세계에서는 일어나지 않지만 컴퓨터 세계에서는 흔한 일
  ```

이러한 이유로 좋은 설계 원칙이라도 때로는 현실과 타협해야할 때가 있다.  
프로그램이 컴퓨터에서 '올바르게' 실행되는게 먼저고, 더 빨리 실행되도록 최적화하는 일은 그 후에 고민해야 한다.

## 13.2 스레드 안전성

일반적으로 이야기하는 스레드 안전성의 정의  
`어떤 객체를 여러 스레드에서 동시에 안전하게 사용할 수 있다면 그 객체는 스레드 안전하다`

Java Concurrency In Practice의 저자 브라이언 게츠가 내린 스레드 안정성의 정의
```
여러 스레드가 한 객체에 동시에 접근할 때, 어떤 런타임 환경에서든 다음 두 조건을 모두 충족하면서  
객체를 호출하는 행위가 올바른 결과를 얻을 수 있다면 '그 객체는 스레드 안전하다'라고 말한다.
- 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요가 없다.
- 추가적인 동기화 수단이나 호출자 측에서 조율이 필요 없다.
```

### 13.2.1 자바 언어의 스레드 안전성

스레드 안전성은 여러 스레드가 **공유하는 데이터**에 대한 것이다. 스레드가 하나이거나 코드에서 다른 스레드와 아무런 데이터를 공유하지 않는다면, 프로그램이 순차적으로 실행되든 여러 스레드가 동시에 실행되든 스레드 안전성 관점에서는 차이가 없다.  

스레드 안전성은 '안전함의 정도'에 따라 여러 단계로 분류된다. 자바에서는 다음과 같이 나눌 수 있다.
```
- 불변
- 절대적 스레드 안전
- 조건부 스레드 안전
- 스레드 호환
- 스레드 적대적
```

**불변**
- 문자 그대로 '변하지 않는다'는 뜻
- 자바 메모리 모델이 개정된 JDK 5 이후 자바 언어에서 불변 객체는 객체 자체의 메서드 구현과 호출자 모두 아무런 안정장치 없이도 스레드 안전하다.(final 키워드)
- 공유 데이터가 객체라면 객체의 메서드가 자신의 상태를 수정하지 않도록 해야 한다.  
  ```java
  java.lang.String 객체의 경우
  - String은 불변 객체
  - 사용자가 호출하는 substring(), replace(), concat() 등의 메서드는 원래의 값을 그대로 둔 채 새로 생성한 String 객체를 반환하는 식으로 구현됨
  ```
  - 객체의 메서드가 자신의 상태에 영향을 주지 않는 방법으로 상태에 해당하는 모든 변수를 final로 선언하는 방법이 있다.

**절대적 스레드 안전**
- 어떤 런타임 환경에서든 호출자가 추가적인 동기화 조치를 할 필요 없다
  - 브라이언 게츠가 제시한 스레드 안전성 정의를 충족  
  => 조건을 만족시키려면 많은 비용이 발생하고 비현실적일 수도 있음
- 자바 API에서 스레드 안전하다고 표시된 클래스 대부분이 절대적 스레드 안전을 의미하지는 않음
  ```java
  - java.util.Vector는 add(), get(), size() 등의 모든 메서드가 synchronized 메서드로 스레드 안전
  - 하지만 멀티스레드 환경에서 호출자가 추가적인 동기화 조치 없이 사용하면 안전하지 않을 수 있음
  ```

**조건부 스레드 안전**
- 일반적으로 '스레드 안전하다'라고 말하는 안전 수준
- 단일 작업을 별도의 보호 조치 없이 스레드로부터 안전하게 수행한다. 하지만 특정 순서로 연달아 호출하는 상황에서도 정확성을 보장하려면 호출자에게 추가로 동기화해야 할 수 있다.
- 자바의 Vector, HashTable, 그리고 Collections 클래스의 synchronized Collection() 메서드로 래핑한 컬렉션

**스레드 호환**
- 객체 자체는 스레드로부터 안전하지 않지만 호출자가 적절히 조치하면 멀티스레드 환경에서도 안전하게 사용할 수 있음
- 이러한 클래스는 일반적으로 '스레드 안전하지 않다'고 말함
- 자바의 클래스 대다수가 이 분류에 속함

**스레드 적대적**
- 호출자가 동기화 조치를 취해도 멀티스레드 환경에서 안전하게 사용할 수 없다는 뜻
- 자바에서는 처음부터 스레드를 지원해 스레드 적대적 코드는 드뭄

### 13.2.2 스레드 안전성 구현

**상호 배제 동기화**
- 가장 일반적이면서 가장 중요한 동시성 보장 수단
- 대표적인 동기화 수단으로 뮤텍스가 있으며, 임계 영역과 세마포어도 상호 배제 구현에 흔히 쓰임
- 자바에서 상호 배제 동기화
  ```
  코드 블록을 동기화하는 synchronized
  - javac로 컴파일하면 monitorenter, monitorexit라는 두 가지 바이트코드 명령어가 생성되며, 각각 동기화 블록 전후에 실행됨
  - 락을 소유한다는 건 실행 비용 측면에서 상당히 무거운 작업
    - 플랫폼 스레드를 정지하거나 깨우려면 운영 체제의 도움을 얻어야함  
      => 사용자 모드와 커널 모드 사이의 모드 전환에서 프로세서 시간을 많이 소모
  
  그 외 java.util.concurrent, java.util.concurrent.locks.Lock
  - 자바 언어에서 Lock 인터페이스를 이용하여 논블록 구조의 상호 배제 동기화를 구현할 수 있게됨  
    => 클래스 라이브러리 수준에서 동기화를 구현하여 다른 스케줄링 알고리즘, 특성, 성능, 의미를 갖는 다양한 락으로 확장할 수 있게 됨
    - ReentrantLock이 대표적인 예
      - synchronized와 똑같이 재진입이 가능한 락
      - 대기 중 인터럽트, 페어 락, 둘 이상의 조건 지정 등 더 향상된 기능을 제공
        - 대기 중 인터럽트: 락을 얻기 위해 대기 중인 스레드가 락을 포기하고 다른 일을 할 수 있음
        - 페어 락: 같은 락을 얻기 위해 대기하는 스레드가 많을 때 락 획득을 시도한 시간 순서대로 락을 얻게 됨
        - 둘 이상의 조건 지정: newCondition() 메서드를 여러 번 호출해 동시에 여러 개의 Condition 객체와 연결 지을 수 있음
  - JDK 5까지는 synchronized가 성능을 크게 떨어뜨려 Lock이 상대적으로 안정적
    - 하지만 JDK 6 이후 버전에서 synchronized 최적화가 이루어져 ReentrantLock과 선택할 때 성능은 고려 대상이 아니게 됨
  - synchronized가 권장되는 상황
    - 자바 구문 수준의 동기화 수단으로 명확하고 간결함
      - Lock 인터페이스는 낯설고 기본 동기화 기능만 필요하다면 synchronized가 나음
    - Lock은 finally 블록으로 락을 해제해야하는 반면 synchronized는 예외 발생 시 락 해제를 JVM이 보장해줌
    - JDK 5에서는 ReentrantLock의 성능이 우수했으나 현재 동기화 최적화는 JVM에 맡기는게 유리
      - synchronized 사용 시 JVM이 스레드 및 락과 관련된 내부 정보를 활용할 수 있음
      - Lock을 사용하면 JVM은 어느 스레드가 어느 락을 소유하고 있는지 알기 어려움
  ```

**논블로킹 동기화**
- 상호 배제 동기화의 큰 문제는 스레드 일시 정지와 깨우기로 인한 성능 저하  
  - 이런 동기화를 블로킹 동기화라고 함
  - 락과 같은 동기화 장치가 없으면 반드시 문제가 생길 것이라 가정하여, 경합이 실제로 벌어지는지와 상관없이 락을 검
- 논블로킹 동기화
  - 하드웨어 명령어 집합이 발전하면서 생겨난 선택지
  - 충돌 감지를 기반으로 작동하는 낙관적 동시성 전략
    - 잠재적으로 위험할 수 있더라도 일단 작업을 진행
    - 공유 데이터 경합 시 충돌이 발생할 경우 보완 조치를 위함  
      => 흔한 조치는 경합이 없을 때까지 계속 재시도하는 것
  - 스레드를 일시 정지할 일이 없어 논블로킹 동기화라고 함
  - 이 방식을 따르는 코딩을 '락프리 프로그래밍'이라고 함

하드웨어가 '의미상 하나지만 여러 여산을 처리해야 하는 특정 작업'을 하나의 프로세서 명령어로 완료되게끔 보장하는 예  
- TAS(Test and Set): 검사와 지정
- FAA(Fetch-and-Add): 페치와 증가
- Swap: 교환
- CAS(Compare-and-Swap): 비교와 교환
- LL/SC(Load-Linked/Store-Conditional): 적재와 저장

CAS 명령어  
```markdown
- CAS 명령어 동작을 위해서는 피연산자 세 개를 요구
  - 메모리 위치(V), 예상하는 이전 값(A), 새로 설정할 값(B)
- CAS 명령어를 수행하는 프로세서는 아래의 작업이 원자적으로 수행함
  1. V의 값이 A와 같으면 V의 값을 B로 갱신
  2. 같지 않으면 갱신을 수행하지 않고, A를 반환
```
- JDK 5부터 자바에서 CAS 연산을 사용
  - sun.misc.Unsafe 클래스의 compareAndSwapInt(), compareAndSwapLong() 등의 메서드로 제공
  - java.util.concurrent.AtomicInteger 클래스의 compareAndSet(), getAndIncrement() 메서드는 Unsafe 클래스의 CAS 연산을 이용해 구현
  - JDK 9부터 VarHandle 클래스를 통해 사용자 프로그램에서 CAS 연산을 이용할 수 있게 됨

**동기화가 필요 없는 메커니즘**
- 공유 데이터를 전혀 사용하지 않는 경우 정확성을 보장해야 할 대상이 없어 동기화 또한 필요가 없게 됨
- 이와 같이 태생부터 스레드에 안전한 코드 두 가지
  ```markdown
  1. 재진입 코드:
    - 순수 코드라고도 함
    - 실행 중 아무 때나 기어들어 다른 코드를 수행하고 와도 상관 없는 코드
    - 메서드의 반환값을 예측할 수 있고 같은 입력에는 항상 같은 결과를 반환한다면 그 메서드는 재진입 가능한 코드라고 할 수 있음
  2. 스레드 로컬 저장소:
    - 코드에서 사용하는 데이터가 다른 코드와 공유해야 할 때 데이터를 공유하는 다른 코드도 같은 스레드에서 수행된다는 보장이 되면  
      공유 데이터의 가시 범위를 동일한 스레드로 제한할 수 있어 동기화가 필요 없다.
    - 예시: 
      - 생산자-소비자 패턴과 같이 큐를 이용하는 아키텍처 대부분은 큐를 소비하는 스레드 수를 하나로 제한
      - 요청 하나당 서버 스레드 하나를 배정하는 고전적인 웹서버
  ```

## 13.3 락 최적화

JDK 6에서 동시성 효율이 크게 개선되었다.  
적응형 스핀, 락 제거, 락 범위 확장, 경량 락, 편향 락 등 다양한 락 최적화 기술이 추가 되었는데, 이 모든 건 데이터를 더 효율적으로 공유하고 스레드 사이의 경합 문제를 해결하여 프로그램 실행 효율을 높이고자 했다.

### 13.3.1 스핀 락과 적응형 스핀

**스핀 락**
- 상호 배제 동기화의 성능 저하 주요 원인인 블로킹의 ~
- 스레드를 대기 상태로 만들지 않고 원하는 락이 해제되는지 스레드를 멈추지 않고 루프를 돌게함
- 스핀 락은 락이 잠시만 잠겨 있을 때는 효과가 좋지만, 장시간 잠겨 있다면 루프만 돌면서 프로세서 자원을 낭비하게 된다.
  => 스핀 락 대기 시간을 제한하고, 제한된 횟수 이상 락을 얻지 못하면 블로킹 방식으로 전환되어야함

**적응형 스핀**
- 스핀 락의 스핀 횟수는 JVM의 모든 락에 똑같이 적용된다. JDK 6에서는 스핀 락을 최적화한 적응형 스핀(adaptive spin)을 도입한다.
  - 적응형이란 스핀 시간이 고정되지 않고, 같은 락의 이전 스핀 시간과 락 소유자의 상태에 따라 결정된다는 뜻
  - 하나의 락 객체에서 스핀 락이 성공하면 가상 머신은 다음번 스핀도 성공할 가능성이 높다고 판단, 기존 스핀 횟수 한계까지 락을 얻지 못하더라도 믿고 조금 더 시도하게 됨

### 13.3.2 락 제거

- 특정 코드 조각에서 런타임에 데이터 경합이 일어나지 않는다고 판단되면 JIT 컴파일러가 해당 락을 제거하는 최적화 기법
  - 락 제거에 대한 판단 근거는 주로 탈출 분석으로 얻음
  - 코드 조각에서 힙 안의 모든 데이터가 탈출하지 않고, 다른 스레드에서 접근하지 않는다고 판단되면 '스택에 있는 데이터'로 취급할 수 있게 됨  
    => 스택의 데이터는 하나의 스레드만 사용하므로 동기화가 필요 없게 됨

락 제거 예시
```java
public String concatString(String s1, String s2, String s3) {
  StringBuffer sb = new StringBuffer();
  sb.append(s1);
  sb.append(s2);
  sb.append(s3);
  return sb.toString();
}
```
- String은 불변 클래스이기 때문에 문자열을 합치면 새로운 String 객체를 생성
- StringBuffer.append() 메서드 내부에는 synchronized 블록이 있고 sb 객체는 락으로 이용됨
- 가상 머신은 sb 객체의 탈출 여부를 분석하여 concatString() 메서드가 바깥으로 탈출하지 않음을 확인
- 해석 모드로 실행될 때는 락이 존재하지만, JIT 컴파일 이후에는 동기화가 제거되어 더 빠르게 실행

### 13.3.3 락 범위 확장

- 코드를 작성할 때는 동기화 블록의 범위를 데이터가 실제로 공유되는 범위에 맞춰 가능한 좁게 줄이는게 좋음
  - 이렇게 하면 동기화 상태에서 수행해야 할 연산의 수가 최소화되어 경합이 생기더라도 스레드들이 락을 최대한 짧게 쓰고 건네주기 때문에 전체적인 대기 시간이 줄어듦
- 연이은 다수의 작업이나 순환문에서 똑같은 락 객체를 반복해서 잠그고 해제하는 상황에서는 스레드 경합이 없더라도 상호 배제 동기화가 빈번하게 일어나 의미 없이 성능만 떨어뜨리게 됨  
  => 가상 머신은 똑같은 락 객체를 잠그는 단편적인 작업을 발견하면 락의 유효 범위를 해당 작업 전체로 늘림, 이것이 락 범위 확장

### 13.3.4 경량 락

### 13.3.5 편향 락
