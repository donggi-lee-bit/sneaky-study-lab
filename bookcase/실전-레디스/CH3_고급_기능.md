# 3. 고급 기능

## 3.1 파이프라인

이전 요청의 응답을 기다리지 않고 새로운 요청을 보낼 수 있는 기능  
여러 명령어를 동시에 처리하여 네트워크 비용을 줄일 수 있음  
- 조건 분기 등을 적용할 수 없어 복잡한 로직 작성이 어려움
- 파이프라인에 쓰기와 읽기 명령이 모두 포함된 경우 쓰기 명령 실행 전
  읽기 명령의 결과를 기다려야 하므로 지연 시간이 길어질 수 있음
- 여러 클라이언트로부터 서로 다른 명령어가 간섭할 수 있어 스크립트의
  원자적 처리를 보장할 수 없음

복잡한 로직 혹은 원자적 처리가 필요할 경우 다음 기술을 사용
- 트랜잭션
- 루아 스크립팅
- 모듈

## 3.2 루아

레디스의 내장 스크립트 언어  
레디스 명령어만으로 처리하기 어려운 조건 분기 등의 명령어를 원자적으로 처리할 수 있음  

### EVAL vs EVALSHA

루아 스크립트 실행 시 스크립트를 레디스에 어떻게 전달하는가의 차이가 있음  
- EVAL : 루아 스크립트 코드를 직접 레디스에 전달하여 실행
- EVALSHA : 스크립트의 SHA1 해시 값을 이용해서 실행 (스크립트는 이미 레디스에 로드되어 있어야함)

1. EVAL 예시
```
EVAL "return ARGV[1]" 0 "hello"

-> "hello"
```

2. EVALSHA 예시
```
# 1. EVAL로 스크립트를 먼저 로드하여 해시를 반환
SCRIPT LOAD "return ARGV[1]"

-> fd8f2b6e60c059c0f13c9a2ea3b71f5c1f8e14a4

# 2. EVALSHA 실행
EVALSHA fd8f2b6e60c059c0f13c9a2ea3b71f5c1f8e14a4 0 "hello"

-> "hello"
```

EVAL 명령어는 매번 루아 스크립트를 레디스 서버로 전송해야하기 때문에 오버헤드가 크다는 단점이 있음  

하지만 스크립트 크기와 네트워크 대역폭 절약 효과가 크지 않을 경우 관리 비용을 절약하기 위해 EVAL 명령어를  
사용하는 것도 하나의 전략이 될 수 있음  

또한 EVALSHA 명령어는 해시값을 가지고 오기 위해 SCRIPT LOAD 명령어를 실행해야 하므로 레디스 서버와의 네트워크 통신 횟수가 증가하는 경향이 있음  

따라서 통신 횟수를 줄이기 위해서 EVAL 명령어를 사용하는 경우도 있음

#### 스크립트 정지

```bash
# 스크립트 무한 반복 실행
127.0.0.1:6379> EVAL 'redis.call("SET", KEYS[1], "bar"); while 1 do redis. debug("infinite loop") end' 1 foo

# 레디스 서버 상태 확인
127.0.0.1:6379> PING
(error) BUSY Redis is busy running a script. You can only call SCRIPT KILL or SHUTDOWN NOSAVE.

# 스크립트 강제 종료 시도 (이미 쓰기 연산이 수행되어 데이터셋이 변경되어 종료 불가)
127.0.0.1:6379> script kill****
(error) UNKILLABLE Sorry the script already executed write commands against the dataset. You can either wait the script termination or kill the server in a hard way using the SHUTDOWN NOSAVE command.

# 레디스 서버 강제 종료 (데이터 저장 없이 강제 종료)
127.0.0.1:6379> shutdown nosave
```

### 레디스 함수

레디스 7.0의 대표 기능으로, 이페머럴 스크립트의 문제점을 보완하기 위한 대체 기능  

레디스 함수는 스크립트 개발 과정 전체를 애플리케이션 로직에서 분리하여 독립적인 개발이 가능하도록 함  

#### 이페머렐 스크립트의 문제점

- 스크립트를 재사용할 수 없어 매번 전체 소스코드를 전송해야 하고 중복 관리가 어려움
- 로직이 클라이언트에 흩어져 있어 버전 관리나 배포 통제가 어려움
- EVALSHA를 사용할 경우 스크립트 해시를 관리해야 하고, 오류 시 예외 처리가 복잡함
- 클라이언트의 스크립트 실행을 제어하기 어려워 보안에 취약할 수 있음

#### redis.call() vs redis.pcall()

루아 스크립트 내부에서 redis 명령을 실행할 때 사용하는 함수  

두 함수는 에러 처리 방식에 차이가 있음  

redis.call()
- 에러 발생 시 런타임 에러를 발생시키고, 스크립트를 즉시 중단

redis.pcall()
- 에러를 반환 값으로 리턴하고, 에러가 발생해도 스크립트가 계속 실행

실패 시 멈춰야 하는 경우 => redis.call
- 쓰기 작업이 포함되어 있고, 실패 시 데이터 정합성에 영향을 줄 수 있을 때

실패해도 계속 로직을 실행해야 하는 경우 => redis.pcall
- 존재하지 않을 수도 있는 키에 대한 접근, optional한 로직 처리, 에러를 수집하거나 무시할 때

## 3.3 트랜잭션

레디스는 MULTI/EXEC 명령어로 트랜잭션을 구성할 수 있으며, MULTI 명령어 이후의 명령어들은  
큐에 저장되고 EXEC 시점에 순차적으로 실행됨  

트랜잭션 실행 중 다음과 같은 이유로 실패하는 경우가 있음
- 문법 오류나 Out of Memory 등으로 명령어를 큐에 넣지 못한 경우
- EXEC 명령어 실행 시 WATCH된 키가 변경된 경우
- EXEC 시 명령어 중 일부가 런타임 오류가 발생시킨 경우

## 3.4 모듈

레디스 모듈은 레디스 소스코드를 수정하지 않고도 C 언어로 구현하여 레디스 서버에 독립적으로 추가할 수 있음  

그로 인해 안전하게 기능을 확장할 수 있고, 업데이트 대응이 쉬워지고, 유지보수 비용이 줄어듦  

#### 파이프라인 vs 이페머럴 스크립트 vs 레디스 함수 vs 트랜잭션 vs 모듈

단순히 여러 명령을 한 번에 보내서 네트워크 비용을 줄이고 싶을 경우 **파이프라인**  

여러 명령을 하나로 묶어 조건문, 반복문 등 복잡한 로직을 실행하고 싶을 경우 **이페머럴 스크립트(EVAL)**  

자주 쓰는 로직을 서버에 등록하고 호출하고 싶을 경우 **레디스 함수**  

명령어 여러 개를 한 번에 실행하고, 중간 상태를 외부에 노출하지 않게 하고 싶을 경우 **트랜잭션**  

레디스에 새로운 기능(그래프, 벡터 검색, AI 추론 등)을 추가하고 싶을 경우 **모듈**  

## 3.5 키 공간 알림

레디스 키 공간 알림은 특정 키에서 발생하는 이벤트를 실시간으로 pub/sub으로 알려주는 기능으로,  
expire, set, del 등 상태 변화 감지에 활용됨  

모든 명령어의 이벤트는 키 값이 변경되는 시점에 알림을 보내는 반면, 만료 이벤트는 TTL이 만료된  
시점이 아닌, 실제 삭제된 시점
- 레디스의 lazy expiration 정책 때문
- 리소스를 아끼기 위해 접근 시점에 삭제하거나, 주기적으로 스캔하여 삭제

## 3.6 클라이언트 측 캐싱

클라이언트 애플리케이션이 자주 조회하는 데이터를 로컬 메모리에 캐싱하고,  
레디스 서버가 해당 키가 변경되었을 때 이를 알림으로 보내주는 메커니즘  

#### 무효화 테이블(invalidation table)

레디스 서버가 어떤 클라이언트가 어떤 키를 조회했는지 추적하기 위해 유지하는 내부 자료구조이며,  
해당 키가 변경되었을 때 정확한 클라이언트에게 무효화 메세지를 전송하기 위해 사용됨  

#### 브로드캐스트 모드

레디스 서버가 모든 키 변경 이벤트를 추적하고, 해당 키가 어느 클라이언트에서 캐시했든 상관없이,  
변경 사실을 브로드캐스트(pub/sub 방식)로 알려주는 방식  

클라이언트가 특정 키를 GET하지 않아도, 변경이 일어나면 무효화 메세지를 수신할 수 있음  

캐시 미스 없이 선제적 무효화 가능  

#### RESP3

Redis Serialization Protocol  
레디스 서버와 클라이언트 간 통신 시 사용하는 바이너리 텍스트 기반 프로토콜  

RESP2에 비해 더 다양한 자료형과 구조화된 응답을 제공하여 클라이언트 개발을 더 직관적이고 효율적으로 만들어줌
