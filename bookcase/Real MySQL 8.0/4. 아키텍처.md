# 4. 아키텍처

MySQL 서버
- MySQL 엔진: 사람의 머리 역할
- 스토리지 엔진: 손발 역할

## 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL 서버 구조  

<img width="429" alt="image" src="https://github.com/user-attachments/assets/fcbaf55c-7326-4829-943f-504172de6267">

- C, JDBC, ODBC, .NET의 표준 드라이버를 제공하여 대부분의 프로그래밍 언어로 MySQL 서버에 쿼리를 사용할 수 있게 지원
- MySQL 서버를 'MySQL 엔진'과 '스토리지 엔진'으로 구분

MySQL 엔진
```markdown
- 커넥션 핸들러
- SQL 파서 및 전처리기
- 옵티마이저
```
스토리지 엔진
```markdown
- MySQL 서버에서 MySQL 엔진은 하나만 사용할 수 있는 것에 반해 스토리지 엔진은 여러 개를 동시에 사용할 수 있음
- 테이블이 사용할 스토리지 엔진을 지정하면 해당 테이블의 모든 읽기 작업, 변경 작업은 정의된 스토리지 엔진이 처리
  - e. g. mysql> CREATE TABLE test (id INT, name VARCHAR(20)) ENGINE=INNODB;
- 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM)나 버퍼 풀(InnoDB)과 같은 기능을 내장하고 있음
```

핸들러 API  
- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청  
  => 핸들러 요청이라고 하며, 여기서 사용되는 API를 핸들러 API라고 함
- 이 핸들러 API를 이용해 MySQL 엔진은 스토리지 엔진과 데이터를 주고받음

### 4.1.2 MySQL 스레딩 구조

MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동하며, 크게 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분할 수 있다.  
- 포그라운드 스레드(클라이언트 스레드)
  - MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
  - 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리
    - MyISAM 테이블: 디스크 쓰기 작업까지 포그라운드 스레드가 처리
    - InnoDB 테이블: 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리
  - 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 스레드 캐시로 되돌아가게 되는데, 이때 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드를 종료
- 백그라운드 스레드
  ```markdown
  - 인서트 버퍼를 병합하는 스레드
  - 로그를 디스크로 기록하는 스레드
  - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 데이터를 버퍼로 읽어 오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드
  ```
  - 일반적인 상용 DBMS에는 쓰기 작업을 버퍼링하여 일괄 처리하는 기능이 탑재되어 있음
    - MyISAM은 쓰기 작업까지 사용자 스레드로 처리하도록 설계되어있음
    - InnoDB의 경우 CUD 쿼리로 데이터가 변경되는 경우 데이터가 디스크에 완전히 저장될 때까지 기다리지 않아도 됨

### 4.1.3 메모리 할당 및 사용 구조

<img width="346" alt="image" src="https://github.com/user-attachments/assets/bb257f9c-854d-4849-9031-cf47d12178d9">

MySQL에서 사용되는 메모리 공간은 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다. 글로벌 메모리 영역은 MySQL 서버가 시작할 때 운영체제로부터 할당된다.  
글로벌 메모리 영역과 로컬 메모리 영역은 MySQL 서버 내에 존재하는 스레드가 공유해서 사용하는 공간인지 여부에 따라 구분되며, 다음과 같은 특성이 있다.

- 글로벌 메모리 영역
  - 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당됨  
    => 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있으며, 생성된 글로벌 영역이 N개라 해도 모든 스레드에 의해 공유됨
  - 대표적인 글로벌 메모리 영역:
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼
- 로컬 메모리 영역
  - (=) 세션 메모리 영역, 클라이언트 메모리 영역
  - 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역으로 클라이언트 커넥션으로부터 요청을 처리하기 위해 스레드를 하나씩 할당하게 됨
  - 대표적인 로컬 메모리 영역:
    - 정렬 버퍼
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

### 4.1.4 플러그인 스토리지 엔진 모델

플러그인 모델을 통해 기본적으로 제공되는 스토리지 엔진 외에 부가적인 기능을 제공할 수도 있으며 사용자가 직접 스토리지 엔진을 개발하는 것도 가능하다.  

</br>

MySQL 서버에서 지원하는 플러그인 예시는 다음과 같다.  
- 인증
- 전문 검색 파서
- 쿼리 재작성
- 비밀번호 검증
- 커넥션 제어

### 4.1.5 컴포넌트

MySQL 8.0부터 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원된다.  
플러그인 아키텍처는 다음과 같은 단점이 있다.
- 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
- MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음
- 상호 의존 관계를 설정할 수 없어서 초기화가 어려움

### 4.1.6 쿼리 실행 구조

<img width="414" alt="image" src="https://github.com/user-attachments/assets/25f298dc-335c-4ccc-bd1a-55e827edd69a">

- 쿼리 파서: 
  - 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만듦
  - 이 과정에서 쿼리 문법 오류가 발견되면 사용자에게 오류 메세지를 전달
- 전처리기: 
  - 파서 트리를 기반으로 쿼리 문장에 구조적인 문제가 있는지 확인
  - 각 토큰을 테이블 이름이나 컬럼 이름 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체 접근 권한 등을 확인하고, 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 걸러지게 됨
- 옵티마이저:
  - 쿼리를 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할
- 실행 엔진:
  - 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할 수행
  - 동작 예시  
    ```markdown
	옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정한 상황
    1. 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
    2. 다시 실행 엔진이 WHERE 절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
    3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 핸들러에게 요청
    4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어오라고 핸들러에게 요청
    5. 만들어진 결과를 사용자나 다른 모듈에 넘김
    ```
- 핸들러(스토리지 엔진):
  - MySQL 서버 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크에 저장하고 디스크로부터 읽어 오는 역할을 담당

### 4.1.8 쿼리 캐시

- SQL의 실행 결과를 메모리에 캐시하고, 동일 SQL 쿼리가 실행되면 테이블을 읽지 않고 즉시 결과를 반환하여 매우 빠른 성능을 보임
- 하지만 테이블의 데이터가 변경되면 변경된 테이블과 관련된 쿼리 캐시는 모두 삭제해야함  
  => 동시 처리 성능 저하를 유발
- MySQL 8.0부터 쿼시 캐시는 MySQL 서버의 기능에서 완전히 제거됨

### 4.1.9 스레드 풀

- MySQL 서버 엔터프라이즈 에디션에서 제공하는 기능  
  - Percona Server의 경우 스레드 풀을 플러그인 형태로 제공
- 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여 동시 처리되는 요청이 많더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 하여 서버의 자원 소모를 줄이는 것이 목적
  - 스케줄링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우에는 쿼리 처리가 더 느려질 수 있어 주의

### 4.1.10 트랜잭션 지원 메타데이터

- 데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보를 '데이터 딕셔너리' 또는 '메타데이터'라고 함
- MySQL 5.7 버전까지 테이블의 구조와 스토어드 프로그램을 파일 기반으로 관리
  - 이러한 파일 기반의 메타데이터는 생성 및 변경 작업이 트랜잭션을 지원하지 않아 MySQL 서버가 비정상적으로 종료 시 일관되지 않은 상태로 남는 문제가 있었음
- MySQL 8.0 버전부터 데이터 딕셔너리와 시스템 테이블이 모두 트랜잭션 기반의 InnoDB 스토리지 엔진에 저장되도록 개선됨
  - 스키마 변경 작업 중간에 MySQL 서버가 비정상적으로 종료되어도 스키마 변경이 완전한 성공 혹은 완전한 실패로 처리됨


## 4.2 InnoDB 스토리지 엔진 아키텍처

- 거의 유일하게 레코드 기반 잠금을 제공
  - 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어남

<img width="427" alt="image" src="https://github.com/user-attachments/assets/c1fe2ad9-7924-48a9-986e-7711f31d32c2">

### 4.2.1 프라이머리 키에 의한 클러스터링

- 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장됨
  - 프라이머리 키 값 순서대로 디스크에 저장
  - 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키 값을 논리 주소로 사용
- 프라이머리 키가 클러스터링 인덱스이기 떄문에 프라이머리 키를 이용한 레인지 스캔이 빠르게 처리될 수 있음
  - 쿼리 실행 계획에서 프라이머리 키가 다른 보조 인덱스에 비해 선택될 확률이 높음

### 4.2.2 외래키 지원

- 외래키는 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM, MEMORY 테이블에서는 사용할 수 없음
- 외래키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요
  - 변경 시에는 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되어 데드락이 발생할 때가 많으므로 개발 시 주의해야함

### 4.2.3 MVCC(Multi Version Concurrency Control)

- 잠금을 사용하지 않는 일관된 읽기를 제공하는 것이 MVCC의 목적
  - InnoDB는 언두 로그를 이용해 이 기능을 구현
- 멀티 버전은 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미
- 격리 수준이 READ_COMMITTED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경 시 절차
  - UPDATE 문으로 레코드의 특정 컬럼을 변경
  - 변경 전 값을 언두 로그에 복사
  - 커밋 실행 여부와 관계 없이 InnoDB의 버퍼 풀은 새로운 값으로 업데이트
  > 디스크의 데이터 파일에는 체크포인트나 InnoDB의 쓰기 스레드에 의해 새로운 값으로 업데이트되어 있을 수 있고 아닐 수도 있음
- 아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 작업 중인 레코드를 조회하면 어떤 데이터를 조회할까?
  - 이는 격리 수준에 따라 다름
  > 격리 수준이 READ_UNCOMMITTED인 경우 InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 반환  
  > READ_COMMITTED나 그 이상의 격리 수준(REPEATABLE_READ, SERIALIZABLE)인 경우에는 아직 커밋되지 않았기 때문에 언두 영역의 변경 전 값을 반환

  => 즉 하나의 레코드에 대해 2개의 버전이 유지되고, 필요에 따라 어느 데이터가 보여지는지 상황에 따라 달라지는 구조

- UPDATE 쿼리를 실행한 뒤:
  - COMMIT 명령을 실행하면 InnoDB는 더이상의 변경 작업 없이 지금의 상태를 영구적인 데이터로 만듦  
    => 커밋 시 언두 영역의 백업 데이터가 바로 삭제되는 것이 아닌 이 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 삭제됨
  - ROLLBACK 명령을 실행하면 InnoDB는 언두 영역에 있는 백업 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제함

### 4.2.4 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행
- 격리 수준이 SERIALIZABLE이 아닌 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ의 수준의 경우 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계없이 바로 실행됨
  - 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용

### 4.2.5 자동 데드락 감지

- InnoDB는 내부적으로 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 '잠금 대기 목록'을 **그래프 형태**로 관리
  - InnoDB의 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아 그 중 하나를 강제 종료시킴
  - 어느 트랜잭션을 강제 종료시킬지 판단하는 기준은 트랜잭션의 **언두 로그 양**이며, 언두 로그 레코드를 더 작게 가진 트랜잭션이 롤백 대상이 됨
    > 언두 로그 양이 적다 -> 롤백 시 처리해야 할 언두의 양이 적다 -> MySQL 서버의 부하가 덜 하다

일반적인 서비스에서는 데드락 감지 스레드가 데드락을 찾아내는 작업은 크게 부담되지 않음  
하지만 동시 처리 스레드가 많은 경우 데드락 감지 스레드는 더 많은 CPU를 소모  
- 동시 처리 스레드가 많거나 트랜잭션이 가진 잠금의 개수가 많아질 경우
  - 데드락 감지 스레드가 잠금 목록을 검사하기 위해 잠금 테이블에 새로운 잠금을 걸고 데드락 스레드를 찾음
  - 데드락 감지 스레드가 느려지면 서비스 쿼리를 처리 중인 스레드가 작업을 진행하지 못하고 대기하면서 서비스에 악영향을 미치게 됨

이러한 문제를 해결하기 위해 MySQL 서버는 `innodb_deadlock_detect` 시스템 변수를 제공  
innodb_deadlock_detect를 OFF로 설정하면 데드락 감지 스레드가 동작하지 않음  

</br>

데드락 감지 스레드가 동작하지 않을 경우 2개 이상의 트랜잭션이 서로가 가진 잠금을 요구하는 상황이 발생해도 아무도 중재하지 않아 무한정 대기하게 됨  
이때 `innodb_lock_wait_timeout` 시스템 변수를 활성화하면 데드락 상황에서 일정 시간이 지나면 자동으로 요청이 실패하고 에러 메세지를 반환하게 됨  

</br>

innodb_deadlock_detect를 OFF로 설정할 경우 innodb_lock_wait_timeout은 기본값인 50초보다 훨씬 낮은 시간으로 설정하여 사용하는 것을 권장함


### 4.2.6 자동화된 장애 복구

TBD

### 4.2.7 InnoDB 버퍼 풀

InnoDB 스토리지 엔진의 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간  
쓰기 작업을 지연시켜 일괄로 처리할 수 있게 해주는 버퍼 역할도 같이 한다.  

</br>

INSERT, UPDATE, DELETE와 같이 데이터를 변경하는 쿼리는 파일 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다. 하지만 버퍼 풀에서 이러한 변경 데이터를 모아서 처리하면 랜덤한 디스크 작업을 줄일 수 있다.  

#### 버퍼 풀 크기 설정

InnoDB 버퍼 풀 크기는 운영체제와 클라이언트 스레드가 사용할 메모리를 고려해 설정해야 한다.  
버퍼 풀의 크기를 적절히 작은 값으로 설정한 후 상황을 봐가면서 증가시켜가는게 최적이다.  
#### 버퍼 풀의 구조

InnoDB 스토리지 엔진은 버퍼 풀이라는 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 페이지를 읽어서 각 조각에 저장한다.  
버퍼 풀의 페이지 크기 조각을 관리하기 위해 크게 LRU(Least Recently Used), Flush, Free 리스트라는 3개의 자료 구조를 관리한다.
- LRU 리스트: 디스크로부터 읽어온 페이지를 최대한 오랫동안 버퍼 풀의 메모리에 유지해서 디스크 읽기를 최소화하기 위함
  <img width="271" alt="image" src="https://github.com/user-attachments/assets/fd018865-c2a5-42a0-9121-f3ad4d31a27a">

  - InnoDB 스토리지 엔진에서 데이터를 찾는 과정
    ```markdown
    1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
      a. InnoDB 어댑티브 해시 인덱스를 이용해 페이지 검색
      b. 해당 테이블의 인덱스(b-tree)를 이용해 버퍼 풀에서 페이지 검색
      c. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지 포인터를 MRU 방향으로 승급
    2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더에 추가
    3. 버퍼 풀의 LRU 헤더에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동(Read Ahead와 같이 대량 읽기의 경우 디스크의 데이터 페이지가 버퍼 풀로 적재는 되지만 실제 쿼리에서 사용되지 않을 수 있으며, 이런 경우 MRU로 이동되지 않음)
    4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고 결국 해당 페이지는 버퍼 풀에서 제거된다. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어지고 MRU의 헤더 부분으로 옮겨진다.
    5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가

    한 번 읽힌 데이터 페이지가 이후에도 자주 사용된다면 해당 데이터 페이지는 버퍼 풀의 MRU 영역에서 계속 살아남게 되고, 반대로 거의 사용되지 않으면 새롭게 디스크에서 읽힌 데이터 페이지들에 밀려 LRU의 끝으로 밀려나 결국은 버퍼 풀에서 제거될 것이다.
    ```
- Flush 리스트: 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록을 관리
  - InnoDB가 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영
  - 리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는 걸 보장하지 않음
    - 반대로 InnoDB 스토리지 엔진이 체크포인트를 발생시켜 디스크의 리두 로그와 데이터 페이지의 상태를 동기화
- Free 리스트: 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록으로, 사용자 쿼리가 디스크의 페이지 데이터를 읽어와야 하는 경우에 사용됨

#### 버퍼 풀과 리두 로그

- InnoDB 버퍼 풀의 용도는 데이터 캐시와 쓰기 버퍼링
- 버퍼 풀은 클린 페이지와 INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가진 더티 페이지를 갖고 있음
- 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 더티 페이지를 디스크로 동기화

#### 버퍼 풀 플러시

- 플러시 리스트 플러시
  - 리두 로그 공간 확보를 위해 오래전에 변경된 데이터 페이지 순서대로 디스크 동기화 작업을 수행
  - 디스크 동기화 작업을 수행하는 스레드를 클리너 스레드
- LRU 리스트 플러시
  - LRU 리스트의 끝부분부터 시작해서 시스템 변수에 설정된 개수만큼 페이지를 스캔하여  
    더티 페이지는 디스크에 동기화하고, 클린 페이지는 Free 리스트로 페이지를 옮김

### 4.2.8 Double Write Buffer

- InnoDB 스토리지 엔진에서 더티 페이지를 디스크로 플러시할 떄 일부만 기록되는 현상을 Partial-page, Torn-page 라고 하며  
  이러한 동작은 하드웨어 오작동이나 시스템의 비정상 종료를 바랭시킬 수 있다.
- 이 같은 문제를 막기 위한 기법 Double Write
  ```markdown
  - 디스크에 변경 내용을 기록하기 전에 더티 페이지를 묶어서 테이블스페이스의 DoubleWrite 버퍼에 기록
  - 더티 페이지를 적당한 위치에 하나씩 랜덤으로 쓰기를 실행
  ```
- DoubleWrite 버퍼는 데이터 파일 쓰기가 중간에 실패했을 때만 동작
  - DoubleWrite 버퍼와 데이터 파일의 페이지를 비교하여 다른 내용을 담고 있으면 DoubleWrite 버퍼의 내용을 데이터 파일 페이지로 복사
- 데이터 무결성이 중요한 서비스에서 활성화 시키는 게 좋음

### 4.2.9 언두 로그

InnoDB는 트랜잭션과 격리 수준 보장을 위해 DML로 변경되기 이전 데이터를 언두 로그에 백업해둠  
이렇게 백업된 데이터는 아래와 같이 사용됨
- 트랜잭션 보장: 
  - 트랜잭션 롤백 시 데이터를 변경 전 데이터로 복구하기 위해 언두 로그에 백업해둔 이전 데이터를 이용해 복구
- 격리 수준 보장:
  - 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터 조회 시 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어 반환하도록 함



### 4.2.10 체인지 버퍼

### 4.2.11 리두 로그 및 로그 버퍼

### 4.2.12 어댑티브 해시 인덱스

### 4.2.13 InnoDB와 MyISAM, MEMORY 스토리지 엔진 비교

## 4.3 MyISAM 스토리지 엔진 아키텍처

4p !!

## 4.4 MySQL 로그 파일

7p !!