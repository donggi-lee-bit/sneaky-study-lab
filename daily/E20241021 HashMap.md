# Map 인터페이스

Map 인터페이스는 키와 값의 쌍으로 데이터를 관리하는 구조를 제공합니다. 각 키는 고유하며, 중복이 허용되지 않습니다. 대표적인 구현 클래스로는 HashMap, TreeMap, LinkedHashMap이 있습니다. 각 구현 클래스는 각각 데이터 정렬 방식과 순서 보장 여부가 다릅니다.

## HashMap

HashMap은 Map 인터페이스의 구현체로, 데이터를 해시 테이블에 저장합니다. 이때 각 키와 값의 쌍은 엔트리(Entry)라는 단위로 관리됩니다. 또한 해시 코드를 통해 버킷(bucket)이라는 슬롯에 엔트리를 저장합니다. null 키와 null 값을 허용하며, 저장된 객체의 순서를 보장하지 않습니다. 시간이 지나면서 데이터의 순서가 변할 수 있기 때문에, 순서가 중요한 경우에는 LinkedHashMap을 사용하는 것이 좋습니다.

또한 HashMap은 스레드 안전하지 않으므로, 여러 스레드가 동시에 접근할 경우 예기치 않은 동작이 발생할 수 있습니다. 이러한 문제를 해결하기 위해 Collections.synchronizedMap()을 사용해 HashMap을 스레드 안전한 상태로 래핑할 수 있지만, 동시성 문제가 중요한 경우 java.util.concurrent 패키지에서 제공하는 ConcurrentHashMap을 사용하는 것이 더 효율적입니다.

### 데이터 추가

HashMap에서 데이터를 추가할 때는 put() 메서드를 사용하며, 이 메서드는 내부적으로 putVal() 메서드를 호출합니다. 해시 테이블에 데이터를 저장할 때 다음과 같은 동작이 이루어집니다.

### 1. 해시 충돌 처리 및 버킷 선택

putVal() 메서드는 키의 해시코드(hashCode)를 계산하여 버킷의 인덱스를 결정합니다. 동일한 해시코드를 가진 여러 키가 있을 수 있기 때문에, **해시 충돌**이 발생할 수 있습니다.

해시 충돌이 발생하면, 기존 버킷의 끝에 새로운 노드를 LinkedList 형태로 추가합니다. 이때 노드의 개수가 8개 이상이 되면, LinkedList가 **트리 구조로 변환**됩니다. 트리 구조로 변환하게 되면서 데이터의 삽입, 삭제, 탐색 성능이 O(log n)으로 최적화됩니다. 트리의 노드 개수가 6개 이하로 줄어들면 다시 LinkedList로 되돌아갑니다.

### 2. 기존 키의 값 업데이트

이미 동일한 키가 존재하면, 새로운 값으로 기존 값을 덮어씌웁니다. **equals()** 메서드를 사용해 키의 동일성을 검사합니다. 이 과정을 통해 **중복된 키**를 허용하지 않고, 동일한 키에 대해 항상 최신 값을 유지합니다.

### 3. 테이블 확장 및 리사이징

HashMap은 동적 배열을 사용하기 때문에, 저장된 데이터가 일정 임계치를 초과하면 배열 크기를 두 배로 확장합니다. 이 과정에서 재해싱(rehashing) 작업이 수행됩니다. 기존에 저장된 모든 키-값 쌍을 새로운 배열에 다시 매핑합니다. 이러한 배열 확장과 재해싱은 모든 키-값 쌍을 새로 매핑하기 때문에 비용이 큰 작업입니다. 하지만 이 과정을 통해 **해시 충돌을 줄이고, 데이터 조회 성능을 유지**할 수 있습니다.
