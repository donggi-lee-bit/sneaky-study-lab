## 컴파일러 최적화 기법

컴파일러는 프로그램 코드를 기계어로 번역하는 것이다. 기계어로 번역하는 일 자체는 어려운 주제가 아니다. 출력 코드가 얼마나 잘 최적화되었느냐가 컴파일러의 우수성을 결정하는 핵심이다. 

[OpenJDK 공식 위키](https://wiki.openjdk.org/display/HotSpot/PerformanceTacticIndex#PerformanceTacticIndex-speculative(profile-based)techniques)에는 핫스팟의 JIT 컴파일러가 이용하는 최적화 기법들이 나열되어 있다. 

</br>

최적화 예시 코드는 다음과 같다.
```java
static class B {
    int value;
    final int get() {
        return value;
    }
}

public void foo() {
    y = b.get();
    // ... something
    z = b.get();
    sum = y + z;
}
```

가장 먼저 진행할 최적화는 메서드 인라인이다. 메서드를 인라인하는 목적은 두 가지다.
```java
1. 메서드 버전 찾기나 스택 프레임 구축 등의 메서드 호출 비용을 없애는 것
2. 다른 최적화를 적용하기 쉽도록 길을 미리 평탄하게 닦는 것 

메서드 인라인은 후속 최적화를 더 큰 규모로 수행하기 쉽게 해주어 더 나은 최종 결과를 낳는 밑거름 역할을 한다.
```
   
</br>

인라인을 적용한 모습은 다음과 같다.
```java
public void foo() {
    y = b.value;
    // ... something
    z = b.value;
    sum = y + z;
}
```  

다음으로 진행할 최적화는 중복 저장 제거다.(코드 중간 주석 부분에서 b.value 값을 변경하지 않는다고 가정)  
중복 저장을 제거한 코드는 다음과 같다.
```java    
public void foo() {
    y = b.value;
    // ... something
    z = y;
    sum = y + y;
}
```  

다음은 복사 전파(copy propagation)을 적용한다.  
변수 y와 완전히 같은 또 다른 변수 z를 사용할 필요가 없다. z 대신 y를 써도 똑같다.
```java
public void foo() {
    y = b.value;
    // ... something
    y = y;
    sum = y + y;
}
```  


네번째 최적화는 죽은 코드 제거다.  
죽은 코드란 실행되지 않을 코드일 수도, 실행해도 의미가 없는 코드일 수도 있다.  
```java
public void foo() {
    y = b.value;
    // ... something
    sum = y + y;
}
```

네 번의 최적화를 거친 코드는 아무런 최적화도 하기 전 코드와 같은 효과를 낸다. 하지만 많은 문장이 제거된 덕분에 바이트코드와 기계어 명령어가 달라지고 실행 효율 측면에서도 차이가 클 것이다.  

### 메서드 인라인

메서드 인라인은 컴파일러 최적화 기법 중 가장 중요하다.  
인라인은 메서드 호출 비용을 없애 주고, 다른 최적화를 수행하기 좋도록 터를 닦아 준다.  

#### 메서드 인라인 동작 원리

- 개념적 : 메서드 호출 비용을 없애기 위해 대상 메서드의 코드를 호출 메서드로 단순히 복사하는 일
- 실제 : JVM에서 복잡한 방식으로 동작
  > - 컴파일 원칙의 최적화 이론에 따르면 대부분 자바 메서드는 인라인 할 수 없음
  > - 아래 메서드를 제외하고 자바 컴파일타임에 해석되는 메서드는 런타임에 메서드 수신자를 선택해야함
  >   - invokespecial 명령어로 호출된 private 메서드
  >   - 인스턴스 생성자
  >   - 슈퍼클래스의 메서드
  >   - invokestatic 명령어로 호출된 정적 메서드
  >
  > => 수신자 버전이 둘 이상일 수 있기 때문  
  > => 기본적으로 자바는 가상 메서드로 존재하게 됨  
  > => 가상 메서드를 인하인 하기 위해 '클래스 계층 구조 분석 기술'을 도입

클래스 계층 구조 분석
- 애플리케이션 타입을 분석하여 현재 로딩된 클래스를 대상으로 인터페이스를 구현했는지, 하위 클래스가 있는지, 상위 클래스의 가상 메서드를 오버라이딩하는지 등을 알 수 있음
  - 가상 메서드가 주어지면 클래스 계층 구조 분석에 의하여 프로그램의 현재 상태에서 후보 버전이 여러 개 존재하는지 확인
    > - 메서드 호출 부담을 줄이기 위해 JIT 컴파일러는 '인라인 캐시'를 찾음
    > - 인라인 캐시 : 대상 메서드에 정상적으로 진입하기 전에 확인하는 캐시
    > - 동작 방식
    >  0. 메서드가 호출되기 전 비어있는 상태
    >  1. 첫번째 호출이 일어나면 메서드 수신자의 버전 정보를 캐시에 기록
    >  2. 이후 메서드가 호출될 때마다 수신자의 버전을 비교
    >  3. 후속 호출들에서도 버전이 매번 똑같다면 '모노모픽 인라인 캐시'라고 함
    >  4. 후속 호출에서 메서드 수신자 버전이 달라지면 프로그램이 가상 메서드의 다형성을 이용하는 것이고, '메가모픽 인라인 캐시'라고 함    
      => 가상 메서드 테이블 방식과 똑같이 부하를 일으킴
  - 후보가 1개라면 애플리케이션이 지금 모습에서 변하지 않을 것이다라고 가정하고 인라인을 수행  
    => 가이디드 인라인

### 탈출 분석

탈출 분석은 새로 만들 객체가 사용되는 범위를 분석하여 자바 힙에 할당할지 여부를 결정하는 기술이다.  
탈출 분석은 먼저 '객체의 동적 범위'를 분석하여 탈출 수준을 다음 세 가지로 구분한다.
1. 전역 탈출(GlobalEscape) : 객체가 메서드 밖으로 빠져나와 다른 스레드가 접근할 수 있게 함
2. 인수 탈출(ArgEscape) : 객체가 인수로 전달되거나 인수에 의해 참조되지만, 호출 도중 전역 탈출은 하지 않음
3. 탈출하지 않음(NoEscape) : 어디로도 탈출하지 않고 메서드 안에서 생애를 마침  

객체의 탈출 수준에 따라 객체 인스턴스에 적용하는 최적화 수준을 달리할 수 있다.
- 스택 할당 : 객체가 탈출하지 않는다면(다른 스레드가 사용하지 않는다고 확신될 때) 스택에 할당  
  =>  스택 할당을 이용하면 객체가 메서드 종료와 함께 자동으로 파괴되어 GC의 부담을 크게 줄일 수 있음
- 스칼라 치환 : 자바 객체를 분해하여 멤버 변수들에 직접 접근할 수 있게 만드는 과정  
  => 탈출 분석을 통해 '메서드 외부에서 접근할 수 없고 분해할 수 있는 객체'라고 증명된다면 애초부터 객체를 생성하지 않을 수 있고, 객체의 멤버 변수를 메서드에서 직접 사용하게 함
- 동기화 제거 : 스레드 동기화는 그 자체로 시간이 오래 걸리는 작업  
  => 탈출 분석 결과 다른 스레드에서 접근할 수 없다고 판단되는 변수는 읽고 쓰는 데 경쟁이 일어나지 않음  

탈출 분석은 비싼 작업이다. 그런데 탈출하지 않는 객체가 거의 없다면 분석에 들인 시간을 낭비하게 된다.  
그래서 현재의 VM은 어쩔 수 없이 정확도가 높지 않은 알고리즘을 사용한다.

### 공통 하위 표현식 제거

공통 하위 표현식 제거는 중복 계산을 제거하는 최적화 기법이다.  
공통 하위 표현식은 최적화 적용 범위에 따라 다음과 같이 구분할 수 있다.  
- 지역 공통 하위 표현식 제거 : 적용 범위가 기본 블록으로 제한
- 전역 공통 하위 표현식 제거 : 둘 이상의 블록에서 중복되는 표현식을 찾아 제거

### 배열 경계 검사 제거

배열 경계 검사는 JIT 컴파일러의 고전적인 언어 특화 최적화 기법이다.  
자바 코드에서 배열을 읽고 쓸 때마다 때마다 경계 검사를 수행하면 프로그램에서는 그만큼 성능 부담으로 다가올 수 있다.  
배열 경계 검사는 안전을 위해 반드시 필요하지만 런타임 시점에 한 번만 수행되도록 할 수 있다.  
- foo[3] 처럼 배열의 인덱스가 상수일 때 컴파일타임에 데이터 흐름을 분석하여 foo.length가 3보다 크다는 사실을 알았다면 실행 중 경계 검사를 하지 않아도 된다.
- 순환문 안에서 루프 변수를 인덱스로 이용하여 배열에 접근할 때 컴파일러가 데이터 흐름을 분석하여 루프 변수의 값이 범위를 벗어나지 않는다고 판단하면 순환문 내에서 경계 검사를 걷어낼 수 있다.  

이러한 보이지 않는 부하를 없애기 위해서는 배열 경계 검사를 최대한 최적화하여 런타임에 수행할 검사를 컴파일타임에 끝마치는게 좋다.    

### 그 외 최적화 기법

이 외에도 자바 언어에 특화된 제거 최적화 기법으로는 오토박싱 제거, 안전 지점 제거, 리플렉션 제거 등이 있다.