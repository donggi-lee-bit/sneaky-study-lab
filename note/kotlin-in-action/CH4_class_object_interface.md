# 클래스, 객체, 인터페이스

## 4.1 클래스 계층 정의

### 4.1.2 open, final, abstract 변경자: 기본적으로 final

- **취약한 기반 클래스(fragile base class) 문제**
    - 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우
    - 클래스를 상속하는 방법에 대해 정확한 규칙을 제공하지 않는다면 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메서드를 오버라이드할 위험 존재
    - 이펙티브 자바에서는 상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라라는 조언

      → 하위 클래스에서 오버라이드하게 의도된 클래스와 메서드가 아니라면 모두 `final`로 만들라는 뜻

- **코틀린의 상속**
    - 코틀린에서 클래스의 상속을 허용하려면 클래스 앞에 `open` 변경자를 붙여야 함
    - 오버라이드를 허용하고 싶은 메서드나 프로퍼티 앞에도 `open` 변경자를 붙여야 함
    - 오버라이드하는 메서드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면
        - 오버라이드하는 메서드 앞에 `final` 명시

### 4.1.3 가시성 변경자: 기본적으로 공개

- **코틀린의 가시성 변경자**
    - 기본 가시성
        - 코틀린: `public`
        - 자바: `package-private` (패키지 전용)
        - 코틀린의 패키지 전용 가시성 : `internal`
    - internal
        - 모듈 내부에서만 볼 수 있음 (모듈 → 한꺼번에 컴파일되는 코틀린 파일)
        - 모듈 구현에 대한 진정한 캡슐화를 제공
- **최상위 선언**
    - 자바: 클래스
    - 코틀린: 클래스, 프로퍼티, 함수
    - 코틀린에서의 최상위 선언
        - `private` 가시성을 허용
            - 선언이 들어있는 파일 내부에서만 사용 가능
            - 하위 시스템의 자세한 구현 사항을 외부에 감추고 싶을 때 유용한 방법
- **가시성에 따른 타입 참조**
    - 자신보다 가시성이 더 낮은 타입을 참조하고자 하면 컴파일 에러가 발생
        - e. g. public 함수 안에서 internal 타입 참조 X
- **protected**
    - 자바: 같은 패키지 안에서 접근 가능
    - 코틀린: 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 접근 가능

      → 클래스를 확장한 함수는 그 클래스의 `private`이나 `protected` 멤버에 접근할 수 없음

### 4.1.4 내부 클래스와 중첩된 클래스: 기본적으로 중첩 클래스

- **자바의 중첩 클래스**
    - 클래스 안에 정의한 클래스는 자동으로 `inner` 클래스
        - 바깥쪽 클래스에 대한 참조를 묵시적으로 포함
    - 중첩 클래스를 `static` 으로 선언 시 바깥쪽 클래스에 대한 참조가 사라짐
- **코틀린의 중첩 클래스**
    - 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없음
    - 바깥쪽 클래스에 대한 참조를 하고 싶다면 `inner` 변경자를 붙여야 함
    - inner 클래스에서 바깥쪽 클래스(e. g. Outer)의 참조에 접근하려면 `this@Outer` 와 같이 써줘야 함

### 4.1.5 봉인된 클래스: 클래스 계층 정의 시 계층 확장 제한

- **클래스 계층 정의 시 디폴트 분기 처리**
    - 클래스 계층 정의 시  `when` 식에서 모든 하위 클래스를 처리해줘야 함
    - 코틀린 컴파일러는 `when` 식을 사용할 때 디폴트 분기인 `else` 분기를 덧붙이도록 강제되고 있음 (`else` 분기에서는 반환할 만한 의미 있는 값이 없으므로 예외를 반환)
    - 이후 새로운 하위 클래스가 추가되고, 클래스 처리를 잊어버리더라도 디폴트 분기가 선택되기 때문에 심각한 버그 발생 위험 존재
- **`sealed` 클래스**
    - 상위 클래스에 `sealed` 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있음
    - `sealed` 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 함
    - `sealed` 클래스는 기본적으로 `open` 변경자
    - `when` 식에서 모든 하위 클래스 처리 시 디폴트 분기(`else` 분기)가 필요 없음
    - 이후 새로운 하위 클래스를 추가되면 `when` 식을 고쳐야 정상 작동

      → 버그를 예방할 수 있게 됨

<br></br>

## 4.2 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언

- **코틀린의 생성자**
  - 주 생성자 (primary): 클래스를 초기화할 때 사용하는 간략한 생성자, 클래스 본문 밖에 정의
  - 부 생성자 (secondary): 클래스 본문 안에 정의
  - 초기화 블록 (initializer block)

### 4.2.1 클래스 초기화: 주 생성자와 초기화 블록

```kotlin
class User(val nickname: String)
```

- 클래스 이름 뒤에 오는 괄호로 둘러싸인 코드를 `주(primary) 생성자`
- 정의 목적
  1. 생성자 파라미터 지정
  2. 생성자 파라미터에 의해 초기화되는 프로퍼티 정의

```kotlin
// 1.
class User constructor(_nickname: String) {
    val nickname: String
    
    init {
        nickname = _nickname
    }
    // val nickname: String = _nickname 와 같이 선언하여 init 키워드 생략 가능
}

// 2. 생성자 파라미터 이름 앞에 val을 추가하면 프로퍼티 정의와 초기화를 간략히 할 수 있음
class User(val nickname: String)

// 3. 생성자 파라미터 디폴트 값 정의
class User(val nickname: String = "hello")
```

- `constructor` 키워드
  - 주 생성자, 부 생성자 정의 시 사용
  - 주 생성자 앞에 별도의 애너테이션이나 가시성 변경자가 없으면 생략 가능
- `init` 키워드
  - 클래스의 객체가 만들어질때 실행될 초기화 코드가 들어감